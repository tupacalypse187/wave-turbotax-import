name: ğŸš€ Deploy to Production

permissions:
  packages: write
  contents: read
  security-events: write
  issues: write

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      environment:
        description: "Deployment environment"
        required: true
        default: "production"
        type: choice
        options:
          - production
          - staging
      force_deploy:
        description: "Force deployment (skip tests)"
        required: false
        default: false
        type: boolean

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  DOMAIN: tax.yantorno.party

jobs:
  # ğŸ” Security and Quality Checks
  security:
    name: ğŸ” Security & Quality Checks
    runs-on: ubuntu-latest
    outputs:
      security-passed: ${{ steps.security.outputs.passed }}
      quality-passed: ${{ steps.quality.outputs.passed }}

    steps:
      - name: ğŸ“¥ Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: ğŸ”§ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "18"
          cache: "npm"
          cache-dependency-path: "package-lock.json"

      - name: ğŸ“¦ Install Dependencies
        run: npm ci --prefer-offline --no-audit

      - name: ğŸ” Security Audit
        id: security
        run: |
          echo "Running npm security audit..."
          if npm audit --audit-level moderate --json > audit-report.json; then
            echo "passed=true" >> $GITHUB_OUTPUT
            echo "âœ… Security audit passed"
          else
            echo "passed=false" >> $GITHUB_OUTPUT
            echo "âš ï¸ Security issues found"
            cat audit-report.json | jq -r '.vulnerabilities | keys | .[]' | head -10
          fi

      - name: ğŸ“Š Code Quality Checks
        id: quality
        run: |
          echo "Running quality checks..."

          # ESLint
          if npm run lint; then
            echo "âœ… ESLint passed"
          else
            echo "âŒ ESLint failed"
            exit 1
          fi

          # TypeScript check
          if npm run typecheck; then
            echo "âœ… TypeScript check passed"
          else
            echo "âŒ TypeScript check failed"
            exit 1
          fi

          # Build test
          if npm run build; then
            echo "âœ… Build test passed"
            echo "passed=true" >> $GITHUB_OUTPUT
          else
            echo "âŒ Build test failed"
            echo "passed=false" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: ğŸ“¤ Upload Security Report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: security-audit-report
          path: audit-report.json
          retention-days: 30

  # ğŸ§ª Application Testing
  test:
    name: ğŸ§ª Application Tests
    runs-on: ubuntu-latest
    needs: security
    if: needs.security.outputs.quality-passed == 'true'

    steps:
      - name: ğŸ“¥ Checkout Repository
        uses: actions/checkout@v4

      - name: ğŸ”§ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "18"
          cache: "npm"

      - name: ğŸ“¦ Install Dependencies
        run: npm ci --prefer-offline

      - name: ğŸ§ª Run Unit Tests
        run: npm run test:ci || echo "No unit tests configured"

      - name: ğŸ—ï¸ Test Build Process
        run: |
          npm run build
          echo "Build artifacts:"
          ls -la dist/

      - name: ğŸ“¦ Build Application for Testing
        run: npm run build

      - name: ğŸš€ Preview Build
        run: |
          npx vite preview --port 3000 --host 0.0.0.0 &
          sleep 10
          curl -f http://localhost:3000 || exit 1
          pkill -f "vite preview"

      - name: ğŸ“¦ Upload Build Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-artifacts
          path: dist/
          retention-days: 7

  # ğŸ³ Docker Image Build and Security Scan
  build-image:
    name: ğŸ³ Build & Scan Docker Image
    runs-on: ubuntu-latest
    needs: [security, test]
    if: always() && (needs.security.outputs.quality-passed == 'true' || github.event.inputs.force_deploy == 'true')
    outputs:
      image-digest: ${{ steps.build.outputs.digest }}
      image-tag: ${{ steps.meta.outputs.version }}

    steps:
      - name: ğŸ“¥ Checkout Repository
        uses: actions/checkout@v4

      - name: ğŸ³ Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          buildkitd-flags: --allow-insecure-entitlement security.insecure
          platforms: linux/amd64

      - name: ğŸ” Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: ğŸ·ï¸ Extract Metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}
          flavor: |
            latest=false
            prefix=

      - name: ğŸ”¨ Build and Push Docker Image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile.prod
          platforms: linux/amd64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            APP_VERSION=${{ steps.meta.outputs.version }}
            NODE_ENV=production
            VITE_APP_URL=https://${{ env.DOMAIN }}
            VITE_API_URL=https://api.${{ env.DOMAIN }}
            VITE_TURNSTILE_SITE_KEY=${{ secrets.VITE_TURNSTILE_SITE_KEY }}

      - name: ğŸ” Trivy Security Scan
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ steps.build.outputs.digest }}
          format: "sarif"
          output: "trivy-results.sarif"

      - name: ğŸ“¤ Upload Trivy Scan Results
        if: always()
        uses: github/codeql-action/upload-sarif@v4
        with:
          sarif_file: "trivy-results.sarif"

      - name: ğŸ›¡ï¸ Grype Security Scan
        uses: anchore/scan-action@v3
        id: grype
        with:
          image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ steps.build.outputs.digest }}
          fail-build: false
          severity-cutoff: high
          output-format: sarif

      - name: ğŸ“¤ Upload Grype Scan Results
        if: always()
        uses: github/codeql-action/upload-sarif@v4
        with:
          sarif_file: ${{ steps.grype.outputs.sarif }}

  # ğŸš€ Deploy to Production
  deploy:
    name: ğŸš€ Deploy to Production
    runs-on: ubuntu-latest
    needs: [security, test, build-image]
    if: success() && (needs.build-image.outputs.image-digest != '')
    environment:
      name: production
      url: https://${{ env.DOMAIN }}

    steps:
      - name: ğŸ“¥ Checkout Repository
        uses: actions/checkout@v4

      - name: ğŸŒ Setup Environment
        run: |
          echo "Deploying to: ${{ env.DOMAIN }}"
          echo "Image: ${{ needs.build-image.outputs.image-digest }}"
          echo "Tag: ${{ needs.build-image.outputs.image-tag }}"

      - name: ğŸš€ Deploy via SSH
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.PROD_HOST }}
          username: ${{ secrets.PROD_USER }}
          key: ${{ secrets.PROD_SSH_KEY }}
          timeout: 300s
          command_timeout: 120s
          script: |
            # Set environment variables
            export IMAGE_TAG="${{ needs.build-image.outputs.image-tag }}"
            export IMAGE_DIGEST="${{ needs.build-image.outputs.image-digest }}"
            export DOMAIN="${{ env.DOMAIN }}"
            export REGISTRY="${{ env.REGISTRY }}"
            export IMAGE_NAME="${{ env.IMAGE_NAME }}"

            # Create deployment directory if not exists
            mkdir -p /opt/wave-turbotax
            cd /opt/wave-turbotax

             # Create data directories with proper permissions for bind mounts
             mkdir -p data/prometheus data/grafana
             chmod -R 755 data/

            # Initialize git repo if not exists
            if [ ! -d .git ]; then
              echo "Initializing git repository..."
              git init
              git remote add origin https://github.com/${{ github.repository }}.git
              git fetch origin main
              git checkout -b main origin/main
            else
              # Pull latest configurations
              git fetch origin main
              git checkout main
              git pull origin main || true
            fi

            # Create environment file
            cat > .env.prod << EOF
            APP_VERSION=${IMAGE_TAG}
            IMAGE_DIGEST=${IMAGE_DIGEST}
            DOMAIN=${DOMAIN}
            REGISTRY=${REGISTRY}
            IMAGE_NAME=${IMAGE_NAME}
            NODE_ENV=production
            DEPLOY_TIME=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
            COMMIT_SHA=${{ github.sha }}
            EOF

            # Pull new image
            echo "Pulling new image: ${REGISTRY}/${IMAGE_NAME}:${IMAGE_TAG}"
            docker pull ${REGISTRY}/${IMAGE_NAME}:${IMAGE_TAG}

            # Update running container
            if docker compose -f docker-compose.prod.yml ps | grep -q "Up"; then
              echo "Stopping existing containers..."
              docker compose -f docker-compose.prod.yml down
            fi

            # Start new deployment
            echo "Starting new deployment..."
            docker compose -f docker-compose.prod.yml --env-file .env.prod up -d

            # Wait for health check - Main App
            echo "Waiting for App health check..."
            for i in {1..30}; do
              if curl -f http://localhost:8080/health; then
                echo "âœ… App Health check passed"
                break
              fi
              echo "App Health check attempt $i/30..."
              sleep 5
            done

            # Wait for health check - Prometheus
            echo "Waiting for Prometheus health check..."
            for i in {1..30}; do
              if curl -f http://localhost:9090/-/healthy; then
                echo "âœ… Prometheus Health check passed"
                break
              fi
              echo "Prometheus Health check attempt $i/30..."
              sleep 5
            done

            # Wait for health check - Grafana
            echo "Waiting for Grafana health check..."
            for i in {1..30}; do
              if curl -f http://localhost:3000/api/health; then
                echo "âœ… Grafana Health check passed"
                break
              fi
              echo "Grafana Health check attempt $i/30..."
              sleep 5
            done

            # Verify deployment (Final Aggregate Check)
            if curl -f http://localhost:8080/health && \
               curl -f http://localhost:9090/-/healthy && \
               curl -f http://localhost:3000/api/health; then
              echo "âœ… Full Stack Deployment successful"

              # Show status
              docker compose -f docker-compose.prod.yml ps
              docker images | grep ${IMAGE_NAME}
            else
              echo "âŒ Stack Health check failed"
              docker compose -f docker-compose.prod.yml logs
              exit 1
            fi

      - name: ğŸ” Verify Deployment
        run: |
          # Wait for DNS propagation
          sleep 30

          # Health check
          if curl -f https://${{ env.DOMAIN }}/health; then
            echo "âœ… Production health check passed"
          else
            echo "âŒ Production health check failed"
            exit 1
          fi

          # Check SSL certificate
          if curl -I https://${{ env.DOMAIN }} | grep -q "200 OK"; then
            echo "âœ… HTTPS working properly"
          else
            echo "âš ï¸ HTTPS may have issues"
          fi

      - name: ğŸ“Š Update Deployment Status
        if: always()
        run: |
          # Log deployment info
          echo "Deployment Information:"
          echo "- Domain: ${{ env.DOMAIN }}"
          echo "- Image: ${{ needs.build-image.outputs.image-digest }}"
          echo "- Commit: ${{ github.sha }}"
          echo "- Branch: ${{ github.ref_name }}"
          echo "- Actor: ${{ github.actor }}"
          echo "- Time: $(date -u)"

  # ğŸ§¹ Cleanup and Notifications
  cleanup:
    name: ğŸ§¹ Cleanup & Notifications
    runs-on: ubuntu-latest
    needs: [deploy, build-image]
    if: always()

    steps:
      - name: ğŸ§¹ Cleanup Old Docker Images
        uses: appleboy/ssh-action@v1.0.3
        if: needs.deploy.result == 'success'
        with:
          host: ${{ secrets.PROD_HOST }}
          username: ${{ secrets.PROD_USER }}
          key: ${{ secrets.PROD_SSH_KEY }}
          script: |
            cd /opt/wave-turbotax

            # Clean up old wave-turbotax images only (keep last 3)
            echo "Cleaning up old wave-turbotax images..."
            docker images --format "{{.Repository}}:{{.Tag}}" | \
              grep "${IMAGE_NAME}" | \
              sort -V | \
              head -n -3 | \
              xargs -r docker rmi || true

            # Clean up only unused wave-turbotax containers (not all containers)
            echo "Cleaning up stopped wave-turbotax containers..."
            docker ps -a --filter "name=wave-turbotax" --filter "status=exited" --format "{{.ID}}" | \
              xargs -r docker rm || true

            echo "Cleanup completed"

      - name: ğŸ“§ Notify on Success
        if: needs.deploy.result == 'success'
        run: |
          # Slack notification (if configured)
          if [ -n "${{ secrets.SLACK_WEBHOOK_URL }}" ]; then
            curl -X POST -H 'Content-type: application/json' \
              --data "{\"text\":\"âœ… Wave TurboTax deployed successfully to https://${{ env.DOMAIN }}\n\nğŸ“¦ Image: ${{ needs.build-image.outputs.image-digest }}\nğŸ‘¤ Deployed by: ${{ github.actor }}\nğŸŒ¿ Commit: ${{ github.sha }}\"}" \
              ${{ secrets.SLACK_WEBHOOK_URL }}
          fi

          # Discord notification (if configured)
          if [ -n "${{ secrets.DISCORD_WEBHOOK_URL }}" ]; then
            curl -H "Content-Type: application/json" \
              -X POST \
              -d "{\"content\":\"âœ… **Wave TurboTax Deployed**\n\nğŸŒ **URL**: https://${{ env.DOMAIN }}\nğŸ“¦ **Image**: ${{ needs.build-image.outputs.image-digest }}\nğŸ‘¤ **Deployed by**: ${{ github.actor }}\nğŸŒ¿ **Commit**: ${{ github.sha }}\"}" \
              ${{ secrets.DISCORD_WEBHOOK_URL }}
          fi

          # Email notification (if configured)
          if [ -n "${{ secrets.SMTP_HOST }}" ]; then
            # Create email content
            printf "From: Wave TurboTax CI/CD <${{ secrets.SMTP_FROM }}>\nTo: Admin <${{ secrets.NOTIFICATION_EMAIL }}>\nSubject: âœ… Wave TurboTax Deployed Successfully\n\nYour Wave TurboTax application has been successfully deployed!\n\nğŸŒ URL: https://${{ env.DOMAIN }}\nğŸ“¦ Image: ${{ needs.build-image.outputs.image-digest }}\nğŸ‘¤ Deployed by: ${{ github.actor }}\nğŸŒ¿ Commit: ${{ github.sha }}\nğŸ“… Time: $(date -u)\n\n--\nAutomated by GitHub Actions\n" > email.txt
            
            # Send email
            curl --ssl-reqd \
              --url "smtp://${{ secrets.SMTP_HOST }}" \
              --user "${{ secrets.SMTP_USER }}:${{ secrets.SMTP_PASSWORD }}" \
              --mail-from "${{ secrets.SMTP_FROM }}" \
              --mail-rcpt "${{ secrets.NOTIFICATION_EMAIL }}" \
              --upload-file email.txt
          fi

      - name: ğŸš¨ Notify on Failure
        if: needs.deploy.result == 'failure' || needs.deploy.result == 'cancelled'
        run: |
          # Slack notification
          if [ -n "${{ secrets.SLACK_WEBHOOK_URL }}" ]; then
            curl -X POST -H 'Content-type: application/json' \
              --data "{\"text\":\"ğŸš¨ Wave TurboTax deployment FAILED!\n\nğŸŒ Domain: https://${{ env.DOMAIN }}\nğŸ‘¤ Attempted by: ${{ github.actor }}\nğŸŒ¿ Commit: ${{ github.sha }}\nğŸ“Š Result: ${{ needs.deploy.result }}\n\nğŸ”— Check the workflow: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}\"}" \
              ${{ secrets.SLACK_WEBHOOK_URL }}
          fi

          # Discord notification
          if [ -n "${{ secrets.DISCORD_WEBHOOK_URL }}" ]; then
            curl -H "Content-Type: application/json" \
              -X POST \
              -d "{\"content\":\"ğŸš¨ **Wave TurboTax Deployment FAILED!**\n\nğŸŒ **URL**: https://${{ env.DOMAIN }}\nğŸ‘¤ **Attempted by**: ${{ github.actor }}\nğŸŒ¿ **Commit**: ${{ github.sha }}\nğŸ“Š **Result**: ${{ needs.deploy.result }}\n\nğŸ”— [View Workflow](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})\"}" \
              ${{ secrets.DISCORD_WEBHOOK_URL }}
          fi

  # ğŸ›¡ï¸ Post-Deployment Security Scan
  security-scan:
    name: ğŸ›¡ï¸ Post-Deployment Security Scan
    runs-on: ubuntu-latest
    needs: [deploy]
    if: success()

    steps:
      - name: ğŸ“¥ Checkout Repository
        uses: actions/checkout@v4

      - name: ğŸ”§ Fix Permissions
        run: |
          echo "Skip: Permission fix for security scan"

      - name: ğŸ›¡ï¸ OWASP ZAP Baseline Scan
        continue-on-error: true
        run: |
          docker run -v $(pwd):/zap/wrk/:rw -t ghcr.io/zaproxy/zaproxy:stable zap-baseline.py -t https://${{ env.DOMAIN }} -r report_html.html -a

      - name: ğŸ“¤ Upload Security Report
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: security-scan-results
          path: report_html.html
          retention-days: 30
